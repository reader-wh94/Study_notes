## 분할 메모리 할당 - 세그먼테이션(Segmentation)

> 세그먼테이션

* 세그먼테이션(segmentaion)은 프로세스의 주소 공간을 크기가 다른 여러 개의 세그먼트로 나누고 각 세그먼트를 하나의 연속된 물리 메모리 블록에 배치하는 메모리 관리 기법이다.
* 세그먼트는 프로세스 내에서 연관된 기능을 하는 코드나 데이트들의 블록으로 그 크기는 서로 다르다.
  * 코드 세그먼트 : 프로그램 전체에 걸쳐 작성된 모든 코드들을 모아 하나의 논리적 단위로 구성
  * 데이터 세그먼트 : 프로그램 전체에 걸쳐 선언된 전역 변수들과 정적 변수들을 모은 것
  * 스택 세그먼트 : 함수가 호출될 때, 지역 변수나 매개 변수, 리턴값들을 저장하는 메모리 공간
  * 동적 할당 세그먼트 : 프로세스가 실행 중에 동적으로 할당받는 메모리 영역

<br>

> 세그먼테이션의 구현 - 1. 하드웨어 지원

* 논리 주소 구성
  * 컴파일러는 프로그램 세그먼트들로 나누고 세그먼트 번호를 매긴다.
  * 코드나 데이터의 주소는 세그먼트 상대 주소(offset / 옵셋)로 컴파일한다.
  * **논리 주소 = 세그먼트 번호 + 옵셋(세그먼트 내 상대 주소)**
* CPU
  * 세그먼트 테이블의 시작 주소를 가리키는 레지스터가 필요하다.
  * CPU에 의해 발생하는 논리 주소는 **세그먼트 번호 + 옵셋** 형태이다.
* MMU
  * 논리 주소가 세그먼트 영역 크기를 넘어서는지를 판별하는 기능이 구현되어야 한다.
  * 또한 논리 주소를 물리 주소로 바꾸는 기능이 구현되어야 한다.
* 세그먼트 테이블
  * 프로세스의 논리 세그먼트가 물리 메모리의 어느 위치에 할당되어 있는지 관리하기 위해 세그먼트 테이블을 사용한다.
  * 시스템 전체에 1개의 세그먼트 테이블을 이용한다.
  * 테이블 항목
    * 논리 세그먼트가 할당된 '물리 세그먼트의 시작 위치와 세그먼트의 크기'로 구성
    * 현재 실행 중인 모든 프로세스에 대해 각 논리 세그먼트 당 하나의 항목이 저장

<br>

> 세그먼테이션의 구현 - 2. 운영체제 지원

* 물리 메모리에 현재 할당된 세그먼트의 리스트와 빈 영역(홀 / hole) 리스트를 만들고 관리해야 한다.
* 세그먼트 테이블을 생성, 관리, 유지 해야한다.
* 프로세스가 생성될 때마다 빈 영역 리스트에서 물리 메모리의 빈 영역(free area)을 찾아 세그먼트들을 할당한다.
* 프로세스가 종료할 때마다 할당된 세그먼트를 반환하는 기능을 가지고 있어야 한다.

<br>

> 세그먼테이션의 구현 - 3. 컴파일러, 링커, 로더 지원

* 컴파일러가 사용자 프로그램을 사전에 정의된 세그먼트들로 분할하여 컴파일하고 링킹해야 한다.
* 로더(loader) 역시 실행 파일에 만들어진 논리 세그먼트들을 인지하고 이들을 물리 메모리의 빈 영역을 할당받아 논리 세그먼트를 로딩해야 한다.

<br>

![segmentation](https://user-images.githubusercontent.com/68210266/156704078-f112b521-1fe6-4bda-b5a3-943e7d0882f1.PNG)

**프로세스의 논리 세그먼트와 물리 세그먼트의 매핑**

<br>

> 단편화

* 물리 메모리에서 가변 크기의 세그먼트들을 할당하므로 작은 크기의 홀들이 생기는 **외부 단편화가 발생**한다.
* 논리 세그먼트와 동일한 크기의 물리 세그먼트를 할당하기 때문에 세그먼트 내에서 홀은 발생하지 않아 내부 단편화는 없다.

