## 프로세스 & 스레드 (process & thread)

> 프로그램이란?

실행 가능한 파일의 형태로 하드 디스크나 USB 등의 저장 장치에 저장된 파일이다.

<br>

### Process

> 프로세스 (process)

* 프로그램이 메모리에 로딩되어 실행 중인 작업
* 운영체제로부터 시스템 자원을 할당받는다.
* 할당 받는 시스템 자원
  * CPU 시간
  * 주소 공간
  * Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역
* 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없으며, 접근을 위해서는 IPC 통신이 필요하다.
* 특징
  * 프로세스는 메모리에 적재되어야 실행된다.
  * 프로세스들은 서로 독립적인 메모리 공간을 가진다.
  * 커널은 각 프로세스의 메모리 위치와 크기 정보를 관리한다.
  * 프로세스마다 고유한 번호가 할당된다.
  * 기본적으로 프로세스마다 최소 1개의 스레드를 갖는다. (메인 스레드)

![process1](https://user-images.githubusercontent.com/68210266/153742418-2aeec577-f43c-4040-869b-ac29984afc69.PNG)


<br>

> 프로세스 주소 공간

* Code 영역: 프로세스의 바이너리 코드들이 적재되는 영역. 텍스트(Text) 영역이라고도 불린다. (내가 작성한 코드 + 라이브러리)
* Data 영역: 프로세스의 전역 변수와 정적 변수들을 위해 할당된 영역
* Heap 영역: 프로세스가 실행 중에 동적 할당 받는 영역
* Stack 영역: 함수가 호출될 때, 지역 변수, 매개 변수, 함수의 리턴 값 등을 저장하기 위한 영역


<br>

> 프로세스 제어 블록 (Process Control Block, PCB)

* 특정 프로세스에 대한 중요한 정보를 저장하고 있는 커널 내의 자료구조이다.
* 시스템 전체에 하나의 프로세스 테이블을 두고 현재 실행 중인 모든 프로세스들의 정보를 관리한다.
* OS는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다.
* 프로세스가 생성되면 커널은 PCB를 생성하고 프로세스 테이블의 빈 항목에 PCB를 연결한다. 그리고 프로세스가 종료하면 커널은 PCB를 삭제하고 테이블의 항목에 비어 있음을 표기한다.
* PCB에 저장된 정보
  * 프로세스 번호(Process Identification Number, PID): 프로세스를 유일하게 식별할 수 있도록 고유한 번호
  * 부모 프로세스 번호(Parent Process Identification Number, PPID)
  * 프로세스 상태(Process State): new, running, ready, waiting, terminated 등의 상태를 저장
  * CPU의 컨텍스트 정보(Program Counter 등): 현재 프로세스를 실행하고 있었던 상황을 저장 (PC, SP, 범용 레지스터 등 CPU에 들어 있는 레지스터들의 값)
  * 스케줄링 정보: 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
  * 종료 코드
  * 메모리 관리 정보:  페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다.
  * 입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 오픈 파일 목록
  * 어카운팅 정보: 사용된 CPU 시간, 시간 제한, 계정 번호 등

![process2](https://user-images.githubusercontent.com/68210266/153743230-37c0f751-433b-4d76-8f0f-6787c2bb9406.PNG)

<br>

<br>

### Thread

> 스레드 (thread)의 출현 목적

* 프로세스보다 크기가 작은 실행 단위 필요
* 프로세스의 생성 및 소멸에 따른 오버헤드 감소
* 빠른 컨텍스트 스위칭
* 프로세스들의 통신 시간, 방법, 코딩 등의 어려움 해소

<br>

> 스레드 (thread)

* 프로세스의 실행 단위라고 할 수 있으며, 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
* 작은 크기의 스레드들의 컨테이너는 프로세스이다.
  * 운영체제에게는 스레드를 가지지 않는 프로세스란 있을 수 없다. 
  * 프로세스를 생성할 때 프로세스 낸에 1개의 스레드를 자동으로 생성하는데, 이 스레드를 메인 스레드라고 한다.
* 프로세스는 스레드들의 공유 환경을 제공한다.
  * 스레드는 프로세스 내의 Code, Data, Heap 영역은 다른 스레드와 공유하고 Stack 영역을 따로 할당받는다.
  * 여러 스레드는 한 프로세스 내의 Code, Data, Heap 영역을 공유하지만, 프로세스 간에는 메모리에 접근할 수 없다.
  * 스레드는 별도의 레지스터와 스택을 갖고 있으며, 다른 영역을 공유한다. 따라서 한 스레드가 프로세스의 자원을 변경하면, 다른 스레드도 그 변경 결과를 즉시 확인할 수 있다.

<br>

![thread2](https://user-images.githubusercontent.com/68210266/153815457-2ade7e31-d37a-4204-9a91-2d22190a872b.PNG)

<br>

![thread1](https://user-images.githubusercontent.com/68210266/153815442-d76d8aee-5df3-41a2-bc0b-8a76c2ce6ecc.PNG)

<br>

<br>

### 중간 요약

`프로세스(process)` : 자신만의 고유 공간과 자원을 할당받아 사용하는 작업의 단위

`스레드(thread)` : 프로세스 내에서 실행되는 흐름의 단위로, 다른 스레드와 프로세스의 자원과 공간을 공유하면서 사용

<br>

### Multi Process VS Multi Thread

> Multi Process

* 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.
* 장점
  * 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.(안전성)
* 단점
  1. Context switching에서의 오버헤드
     * 프로세스는 각 독립된 메모리 영역을 할당받았기 때문에 공유하는 메모리가 없다. 따라서 캐시 메모리 초기화 등의 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생할 문제가 있다.
  2. 프로세스 간 통신 기법 IPC
     * 프로세스는 각 독립된 메모리 영역을 할당받았기 때문에 프로세스들 사이에서 변수나 자료구조를 공유할 수 없다. 따라서 IPC라는 방법을 사용해야하며, 이는 어렵고 복잡한 통신 방법이다.

<br>

> Multi Thread

* 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드가 하나의 작업을 처리하도록 하는 것이다.
* 현재 대부분의 멀티 프로세싱 응용 프로그램은 멀티 스레드로 개발한다.
* 멀티 스레딩은 각 작업을 하나의 스레드가 감당하도록 하여 여러 스레드를 동시에 실행시키는 기법이다.
* 장점
  * 메모리 공간과 시스템 자원 소모가 줄어들게 된다.
  * 스레드 간 통신 시, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용해 데이터를 주고 받으므로 통신 방법이 간단하다.
  * Context switching 시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠른다.
  * 시스템의 처리량이 향상되고 자원 소모가 줄어들며, 자연스러벡 프로그램의 응답 시간이 단축된다.
* 단점
  * 서로 다른 스레드가 Data, Heap 영역 등을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 잘못된 값을 읽어오거나 수정할 수 있다. -> 자원 공유의 문제가 발생(동기화)
  * 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다.

출처 : [프로세스 vs 스레드](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.md)
