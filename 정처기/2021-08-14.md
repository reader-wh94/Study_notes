### 1과목 예상 키워드

> 스크럼 개발 프로세스

스프린트 계획 회의 -> 스프린트 -> 일일 스크럼 회의 -> 스프린트 검토 회의 -> 스프린트 회고



> XP 핵심 가치

의사소통, 단순성, 용기, 존중, 피드백



> 요구사항 개발 프로세스

도출 -> 분석 -> 명세 -> 확인



> UML

- 사물 : 구조, 행동, 그룹, 주해
- 관계 : 집합(◇ㅡ), 포함(◆ㅡ), 의존(<·······), 일반화(◁ㅡ), 실체화(◁---)
- 다이어그램
  - 정적 모델링 -> 구조적 다이어그램 : 클래스, 객체, ****컴포넌트, 배치(구현단계)****, 복합체, 패키지
  - 동적 모델링 -> 행위 다이어그램 : 유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 상호작용, 타이밍



> UI

- 와이어프레임 : 뼈대
- 목업 : 정적형태
- 스토리보드 : 와이어프레임 + 이동 흐름, 설명
- 프로토 타입 : 인터랙션, 테스트



> 품질 요구사항

- 기능성(적합성, 정밀성, 상호운용성, 보안성, 호환성)
- 신뢰성(성숙성, 고장 허용성, 회복성)
- 사용성(이해성, 학습성, 운용성, 친밀성)
- 효율성(시간 / 자원 효율성)
- 유지보수성(분석성, 변경성, 안정성, 시험성)
- 이식성(적용성, 설치성, 대체성, 공존성)



> 소프트웨어 아키텍쳐

- 모듈화 : 모듈의 개수와 크기는 반비례, 개수와 비용은 비례
- 추상화 : 세분화하여 구체화
  - 과정 추상화 : 전반적인 흐름
  - 데이터 추상화 : 데이터의 세부사항 정의 x
  - 제어 추상화 : 이벤트의 발생의 세부사항 정의 x



> 아키텍쳐 패턴

- 레이어 패턴
  - 계층식 마주보는 두 계층사이 상호작용
  - 상위 : 서비스 제공자 / 하위 : 클라이언트
- 클라이언트 서버
  - 하나의 서버 다수의 클라이언트
  - 요청을 위한 동기화를 제외하곤 독립적
- 파이프 필터
  - 데이터 스트름 절차의 각 단계를 캡슐화하여 파이프를 통해 전송
  - 데이터 변환, 버퍼링, 동기화
- MVC(모델 뷰 컨트롤러) 패턴
  - 모델 : 서브시스템의 핵심 기능과 데이터 보관
  - 뷰 : 사용자에게 정보 표시
  - 컨트롤러 : 사용자로부터 받은 입력 처리
  - 대화형 애플리케이션
- 마스터-슬레이브 : 작업 분할 후 다시 돌려받음
- 브로커 패턴 : 브로커 컴포넌트가 요청에 맞는 컴포넌트 연결
- 피어투피어 패턴 : 피어가 서버도 되고 클라이언트도 됨
- 이벤트 버스 : 구독한 리스너에게 메시지 받아 이벤트 처리
- 블랙보드 : 검색을 통해 블랙보드에서 데이터 찾음



> 모듈

- 결합도는 약하게 응집도는 강하게
- 결합도 : 모듈 간의 관계
  - 내용 : 내부 기능, 내부 자로 참조
  - 공통 : 공통 데이터 영역
  - 외부 : 외부의 다른 모듈에서 참조
  - 제어 : 제어 신호 이용하여 통신하거나 요소를 전달
  - 스탬프 : 자료구조가 전달됨
  - 자료 : 매개변수 데이터 넘겨줌
- 응집도 : 모듈 내부 요소가 관련된 정도
  - 기능적 : 단일 문제와 연관
  - 순차적 : 모듈에서 나온 데이터가 다음 모듈의 입력
  - 통신적 : 동일한 입력과 출력하여 서로 다른 기능
  - 절차적 : 다수 기능 시 기능을 순차적으로 수행
  - 시간적 : 특정 시간
  - 논리적 : 유사한 성격 혹은 특정 형태
  - 우연적 : 관련 없는 요소들로 구성



> 디자인 패턴

​	GoF 디자인 패턴: 생성 패턴, 구조 패턴, 행위 패턴

- 생성 패턴
  - 추상 팩토리 : 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
  - 빌더 : 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체 생성
  - 팩토리 메소드 : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
  - 프로토타입 : 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
  - 싱글톤 : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할 수는 없음
- 구조 패턴 : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
  - 어댑터 : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
  - 브리지 : 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴
  - 컴포지트 : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
  - 데코레이터 : 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
  - 퍼싸드 : 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구상함으로써 서브 클래스의 기능을 간편하게 사용할 수 있도록 하는 패턴
  - 플라이웨이트 : 인스턴스가 필요할 때마다 생성하는 것이 아닌 공유해서 사용함으로써 메모리를 절약하는 패턴
  - 프록시 : 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
- 행위 패턴 :클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의한 패턴
  - 책임 연쇄 : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
  - 커맨드 : 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
  - 인터프리터 : 언어에 문법 표현을 정의하는 패턴
  - 반복자 : 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
  - 중재자 : 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
  - 메멘토 : 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
  - 옵서버 : 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
  - 상태 : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
  - 전략 : 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
  - 템플릿 메소드 : 상위 클래스에서 골격을 정의하고 하위 클래스에서 처리를 구체화하는 구조의 패턴
  - 방문자 : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴



> 요구사항 검증 방법

- 동료 검토 : 직접 설명하는걸 동료들이 들으면서 결함 발견
- 워크 스루 : 미리 배포하여 사전 검토 후 짧은 회의를 통해 발견
- 인스펙션 : 검토 전문가들이 발견
- CASE : 일관성 분석을 통해 표준 준수 여부 확인



> CASE(Computer Aided Software Engineering)

* 일관성 분석을 통해 요구사항 변경사항의 추적, 분석, 관리하고 표준 준수 여부를 확인
* 기능
  * 그래픽 지원
  * 소프트웨어 생명주기 전반적인 단계의 연결
  * 다양한 소프트웨어 개발 모형을 지원
* 상위 CASE의 기능
  * 모델 사이 모순검사 기능
  * 모델의 오류 검증 기능
  * 자료흐름도 작성 기능



> 데이터 흐름도(Data Flow Diagram)

* 자료 흐름 그래프 또는 버블 차트라고 부르기도 함
* 구조적 분석 기법에 사용
* 구성 요소
  * 프로세스(Process): 원
  * 데이터 흐름도(Data Flow): 화살표
  * 자료 저장소(Data Store): 직선
  * 단말(Terminator): 사각형



> 정형 분석

* 구문과 의미를 갖는 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현한 후 이를 분석



> 객체 지향 설계 원칙

* 단일 책임 원칙 (SRP, Single responsible principle): 한 클래스는 하나의 책임만 가져야 한다
* 개방 폐쇄 원칙(OCP, Open/closed principle): 확장에는 열려있으나 변경에는 닫혀있어야 한다
* 리스코프 치환 원칙(LSP, Liskov substitution principle): 서브 타입(하위 클래스)는 어디서나 자신의 기반 타입(상위 클래스) 인스턴스로 바꿀 수 있어야한다
* 인터페이스 분리 원칙(ISP, Interface segregation principle): 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
* 의존관계 역전 원칙 (DIP, Dependency inversion principle): 추상화에 의존



> 럼바우(Rumbaugh) 객체지향 분석 기법

* 객체 모델링: 객체 다이어그램, 정보 모델링이라고도 하며 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의
* 동적 모델링: 상태 다이어그램, 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현
* 기능 모델링: 자료 흐름도(DFD), 프로세스들의 자료 흐름을 중심으로 처리 과정 표현
* 절차: 객체 모델링 -> 동적 모델링 -> 기능 모델링



> 시스템 연계 기술

- DB Link, API/Open API, EAI(송수신 처리 현황 모니터링, 통제), Socket, Web Service



> 미들웨어

- RPC : 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출
- MOM : 메시지 기반의 비동기형 메시지 전달
- TP-Monitor : 트랜잭션 처리 및 감시
- ORB : 객체 지향 미들웨어
- WAS : 동적인 콘텐츠 처리

------

### 2과목 예상 키워드

> 자료구조

- 배열 : 첨자로 접근
- 선형 리스트
  - 연속 리스트 : 배열을 이용, 삽입 / 삭제 시 자료 이동 용이
  - 연결 리스트 : 포인터 이용, 접근 속도 느리고 기억 공간 효율이 좋지 않음
- 스택 : LIFO
- 큐 : FIFO
- 트리
  - 노드와 가지를 이용하여 구성
  - 트리의 디그리 : 노드들 디그리 중 가장 많은 수
  - 이진트리: 차수(degree)가 2 이하인 노드들로 구성된 트리
- 트리 운행법
  - preorder: root -> left -> right
  - inorder: left ->  root -> right
  - postorder: left -> right -> root
- 수식 표기법
  - prefix: 연산자 -> left -> right
  - infix: left -> 연산자 -> right
  - postfix: left -> right -> 연산자



> 정렬

* 삽입 정렬: O(n^2)
* 선택 정렬: O(n^2)
* 버블 정렬: O(n^2)
* 쉘 정렬: O(n^2)
* 퀵 정렬: O(n^2)
* 힙 정렬: O(nlogn)
* 병합 정렬: O(nlogn)



> 데이터베이스의 정의

- 통합된 데이터 : 중복 최소화
- 저장된 데이터 : 저장 매체 저장
- 운영 데이터 : 고유한 업무 수행
- 공용 데이터 : 여러 시스템 공동 소유



> DBMS 기능

- 정의 : 타입 및 구조 명시하는 기능 (DDL)
- 조작 : 검색, 갱신, 삭제, 삽입하는 기능 (DML)
- 제어 : 무결성 유지, 보안 유지, 권한 검사, 병행 제어 (DCL)



> 트랜잭션

- 하나의 논리적 기능 수행 작업 단위
- 한꺼번에 수행될 일련의 연산
- TCL : COMMIT, ROLLBACK, SAVEPOINT



> 테스트 케이스

- 테스트 항목에 대한 명세서
- 입력 데이터, 테스트 조건, 예상 결과를 모아 만듬

- 계획/제어 -> 분석/설계 -> 구현/실현 -> 평가 -> 완료



> 빌드 도구

- 소스 코드를 소프트웨어로 변환
- Ant : 자바 빌드
- Maven : Ant 대안 의존성 라이브러리 관리
- Gradle : 안드로이드 스튜디오



> 디지털 저작권 관리(DRM)

- 클리어링 하우스 : 사용 권한, 라이선스 발급, 사용량에 따른 결제 관리 등 수행
- 콘텐츠 제공자 : 저작권자
- 패키저 : 암호화 프로그램
- 콘텐츠 분배자 : 암호화 콘텐츠 유통
- 콘텐츠 소비자 : 콘텐츠 사용
- DRM 콘트롤러 : 콘텐츠 이용 권한 통제 프로그램
- 보안 컨테이너 : 콘텐츠 원본 전자적 보안 장치
- 기술 요소
  - 암호화
  - 키 관리
  - 암호화 파일 생성
  - 식별 기술
  - 저작권 표현
  - 정책 관리
  - 크랙 방지
  - 인증



> 소프트웨어 버전 등록

- Import(빈 저장소에 파일 복사) -> checkout(저장소에서 소스 파일 및 버전 관리 파일 받음) -> commit(갱신) -> update(저장소의 최신 버전 동기화) -> diff



> 버전 관리 도구

- 공유 폴더 방식
- 클라이언트 / 서버 방식
  - 서버의 자료를 복사하여 작업 후 서버에 반영
  - 서버에서 버전 관리
  - SVN : trunk 에서 작업 후 추가 작업은 branches 디렉토리 안에 작업 후 trunk와 병합, 리버전
- 분산 저장소 방식
  - 하나의 원격 저장소와 분산된 PC의 로컬 저장소에 함께 저장되어 관리
  - Git : 브랜치를 이용하여 다양한 형태의 테스트, 스냅샷



> 형상 관리

* 소프트웨어의 변경 사항을 관리하기 위한 활동
* 중요성
  * 지속적으로 변경사항을 체계적으로 관리 및 추적할 수 있음
  * 발견된 버그나 수정 사항을 추적
  * 무절제한 변경 방지
* 기능
  * 형상 식별
  * 버전 제어
  * 형상 통제
  * 형상 감사
  * 형상 기록



> 애플리케이션 테스트

- 확인(Validation) : 사용자 입장에서 요구사항을 만족하는지
- 검증(Verification) : 개발자 입장에서 명세서에 맞게 만들어 졌는지

- pareto 법칙 : 애플리케이션의 20%의 코드에서 80% 결함이 발견
- 정적 테스트 : 프로그램 실행 없이 소스코드나 명세서 분석
- 동적 테스트 : 프로그램 실행
- 화이트박스 테스트 : 원시 코드를 오픈하여 모든 경로를 실행하면서 테스트
  - 조건 검사, 루프 검사, 데이터 흐름 검사
  - 문장 검증 기준, 분기 검증 기준, 조건 검증 기준, 분기/조건 검증 기준
- 블랙박스 테스트 : 특정 기능이 작동되는 것을 입증하는 테스트
  - 동등 분할 검사, 경계값 분석, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사

- 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트
- 통합 테스트 : 모듈 간 상호 작용 오류 검사
  - 비점진적 : 미리 결합되어 있는 것을 테스트, 빅뱅 통합
  - 점진적 : 모듈 단위로 통합하면서 테스트, 하향식, 상향식, 혼합식
    - 하향식 : 상위 모듈에서 하위 모듈 방향, 스텁
    - 상향식 : 하위 모듈에서 상위 모듈 방향, 드라이버
    - 혼합식 : 샌드위치 통합 테스트

- 인수 테스트 : 사용자의 요구사항을 만족하는지 테스트
  - 알파테스트 : 개발된 환경에서 개발자 앞에서
  - 베타테스트 : 사용자 환경에서 사용자가 직접



> 테스트 오라클

- 정의된 참 값을 대입하여 비교
- 제한된 검증, 수학적 기법, 자동화 기능
- 참 오라클, 샘플링 오라클, 추정 오라클, 일관성 검사 오라클



> 모듈 연계

- EAI : 기업 내 상호 연동이 가능하게 해주는 솔루션
  - point to point, Hub & Spoke, Message Bus(미들웨어를 두어 처리), Hybrid
- ESB : 애플리케이션 간 표준 기반 인터페이스 제공



> 인터페이스 구현 검증 도구

- xUnit : java, C++, .Net
- STAF : 서비스 호출 및 컴포넌트 재사용
- FitNesse : 웹 기반
- NTAF : FitNess + STAF, NHN의 프레임워크
- Selenium : 다양한 브라우저 및 개발 언어
- watir : Ruby

-----------

### 3과목 예상 키워드

> Key

* 후보키
  * 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합
  * 기본키로 사용할 수 있는 속성
  * 유일성과 최소성의 성질을 만족
* 기본키
  * 후보키 중에서 선택한 Main Key로 NULL 값이 될 수 없음
  * 특정 튜플을 유일하게 구별할 수 있는 속성
* 대체키
  * 보조키
  * 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말함
* 슈퍼키
  * 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
  * 유일성은 만족하지만 최소성은 만족시키지 못함
* 외래키
  * 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합



> 정규화

* 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장
* 이상
  * 삽입 이상
  * 삭제 이상
  * 갱신 이상
* 정규화 과정
  * 1NF: (비정규 릴레이션 -> 1NF)
    * 도메인이 원자값
  * 2NF: (1NF -> 2NF)
    * 부분적 함수 종속 제거
  * 3NF: (2NF -> 3NF)
    * 이행적 함수 종속 제거
  * BCNF: (3NF -> BCNF)
    * 결정자이면서 후보키가 아닌 것 제거
  * 4NF: (BCNF -> 4NF)
    * 다치 종속
  * 5NF: (4NF -> 5NF)
    * 조인 종속성 이용

> 암호 알고리즘

* 개인키 암호화 (양방향)
  * 대칭 암호 기법, 단일키 암호화
  * 블록 암호화: 한 번에 하나의 데이터 블록을 암호화 (DES, SEED, AES, ARIA)
  * 스트림 암호화: 평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화 (LFSR, RC4)
* 공개키 암호화(양방향)
  * 비대칭 암호 기법
  * RSA
* 해시 (단방향)
  * SHA 시리즈, MDS, N-NASH, SNEFRU



> 스키마(Schema)

* 외부 스키마(External Schema)
  * 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 DB의 논리적 구조를 정의
  * 같은 데이터베이스에 대해서도 서로 다른 관점을 정의할 수 있도록 허용한다
* 내부 스키마(Internal Schema)
  * 실제 DB에 저장될 레코드의 물리적인 구조를 정의하고 저장 데이터 항목의 표현 방법을 나타냄
  * 물리적인 저장장치와 밀접한 계층
* 개념 스키마(Conceptual Schema)
  * DB의 전체적인 논리적 구조로서 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 DB로 하나만 존재
  * 개체 간의 관계와 제약 조건을 나타내고 DB의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의

--------

### 5과목 예상 키워드

> 소프트웨어 개발 표준

* ISO/IEC 12207
* CMMI(능력 성숙도 통합 모델)
  * 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가
  * 성숙도는 초기, 관리, 정의, 정량적 관리, 최적화로 구분
* SPICE(소프트웨어 처리 개선 및 능력 평가 기준)
  * 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준
  * ISO/IEC 15504
  * 프로세스
    * 고객-공급자 프로세스, 공학 프로세스, 지원 프로세스, 관리 프로세스, 조직 프로세스
  * 수행 능력 관계
    * 불완전, 수행, 관리, 확립, 예측, 최적화



> 다중화(Multiplexing)

* 효율적인 전송을 위하여 넓은 대역폭을 가진 하나의 전송링크를 통하여, 여러 신호/데이터를 동시에
  실어 보내는 기술
* 주파수 분할 다중화 (FDM ; Frequency-Division Multiplexing)
* 시분할 다중화(TDM ; Time-Division Multiplexing)
* 동기식 시분할 다중화(Synchronous TDM)
* 비동기식 시분할 다중화(Asynchronous TDM)



> OSI-7 계층

* 물리 계층
  * 데이터 단위: 비트
  * 기능: 절차적 특성에 대한 규칙 정의
  * 표준: RS-232C, X.21
  * 장비: 리피터, 허브
* 데이터 링크 계층
  * 데이터 단위: 프레임
  * 기능: 흐름 제어, 동기화, 오류&순서 제어
  * 표준: HDLC, LAPB, LLC, MAC, LAPD, PPP
  * 장비: 브릿지, 스위치
* 네트워크 계층
  * 데이터 단위: 패킷
  * 기능:  경로 설정, 트래픽 제어, 패킷 정보 전송, 데이터 교환&중계
  * 표준: X.25, IP
  * 장비: 리피터, 허브
* 전송 계층
  * 데이터 단위: 세그먼트
  * 기능: 현결 해제, 주소 설정, 다중화, 오류&흐름제어
  * 표준: TCP, UDP
  * 장비: 게이트웨이
* 세션 계층
  * 데이터 단위: 메시지
  * 기능: 대화 구성 및 동기 제어, 데이터 교환 관리
* 표현 계층
  * 데이터 단위: 메시지
  * 기능: 코드 변환, 데이터 암호화&압축, 구문 검색, 정보 형식 변환, 문맥 관리
* 응용 계층
  * 데이터 단위: 메시지
  * 기능: 정보 교환, 파일 전송, 전자사서함, 가상터미널



> TCP/IP, UDP, RTCP

* TCP
  * 전송 계층
  * 양방향 연결
  * 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능
  * 스트림(stream) 전송 기능
* IP
  * 네트워크 계층
  * 데이터그램을 기반으로 하는 비연결형 서비스
  * 패킷의 분해/조립, 주소 지정, 경로 선택 기능
  * 헤더의 길이는 최소 20Byte에서 최대 60Byte
* UDP
  * 비연결형
  * 오버헤드 적음
  * 실시간 전송에 유리
* RTCP
  * 전송 품질 제어
  * 세션에 참여한 참여자에게 주기적으로 전송
  * 하위 프로토콜에게 다중화 제공

<br>

[출처](https://1d1cblog.tistory.com/87)