## 2021-08-30

### 2-2. 물리 데이터 저장소 설계

> 물리 데이터 모델링 변환 절차

* 개체를 테이블로 변환 -> 속성을 컬럼으로 변환 -> UID를 기본키로 변환 -> 관계를 외래키로 변환 -> 컬럼 유형과 길이 정의 -> 반 정규화 수행 

<br>

> 물리 데이터 저장소 구성

**테이블 제약조건(Constraint) 설계**

* 참조무결성 제약조건: 릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조건, 두 개의 릴레이션이 기본키, 외래키를 통해 참조 관계를 형성할 경우, 참조하는 외래키의 값은 항상 참조되는 릴레이션에 기본키로 존재해야 한다.
  * 제한(Restricted): 참조무결성 원칙을 위배하는 연산을 거절하는 옵션
  * 연쇄(Cascade): 참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제하는 옵션
  * 널 값(Nullify): 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 NULL 값을 넣는 옵션이다. NULL 값이 들어갈 애트리뷰트에 'NOT NULL'이라고 명시되어 있다면 삭제 연산을 거절한다.

<br>

**인덱스(Index) 설계**

* 인덱스 개념
  * 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터구조이다.
  * 인덱스를 통해 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조회가 가능하다.
* 인덱스 컬럼 선정
  * 분포도가 좋은 컬럼은 단독적으로 생성한다.
  * 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성한다.
  * 가능한 한 수정이 빈번하지 않은 컬럼을 선정한다.
* 설계 시 고려 사항
  * 지나치게 많은 인덱스는 오버헤드(Overhead)로 작용한다.
  * 인덱스는 추가적인 저장 공간이 필요함을 고려해야 한다.
  * 넓은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킬 수 있음에 유의해야 한다.
  * 인덱스와 테이블의 저장 공간을 적절히 분리될 수 있도록 설계해야 한다.

<br>

**뷰(View) 설계**

* 뷰 속성

  ![뷰 속성](https://user-images.githubusercontent.com/68210266/131305180-6bb171b8-dcbe-4a6f-9088-01d5e97c3690.PNG)

<br>

**클러스터(Cluster) 설계**

* 적용 기준
  * 인덱스의 단점을  해결한 기법으로, 분포도가 넓을수록 오히려 유리하다.
  * 엑세스 기법이 아니라 액세스 효율 향상을 위한 물리적 저장 방법이다.
  * 대량의 범위를 자주 액세스하는 경우 적용한다.
  * 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용한다.
  * 여러 개의 테이블이 빈번하게 조인을 일으킬 때 활용한다.
* 클러스터 설계 시 고려 사항
  * 검색 효율은 높여주나 입력, 수정, 삭제 시는 부하가 증가함을 고려한다.
  * 수정이 자주 발생하지 않는 컬럼은 검토 대상이다.
  * 처리 범위가 넓어 문제가 발생하는 경우는 단일 테이블 클러스터링을 고려한다.
  * 조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링을 고려한다.

<br>

**파티션(Partition) 설계**

* 레인지 파티셔닝(Range Partitioning)
  * 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법
  * 손쉬운 관리 기법을 제공하여 관리 시간의 단축이 가능
  * ![레인지 파티셔닝](https://user-images.githubusercontent.com/68210266/131306927-9b86509e-c409-4388-839f-43e3123fd092.PNG)

* 해시 파티셔닝(Hash Partitioning)
  * 파티션 키의 해시 함수 값에 의한 파티셔닝 기법
  * 균등한 데이터 분할이 가능하고 질의 성능이 향상 가능
  * ![해시 파티셔닝](https://user-images.githubusercontent.com/68210266/131307077-93877642-1a34-4b3d-89f0-0e7bd3b8cc48.PNG)

* 리스트 파티셔닝(List Partitioning)
  * 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법
  * 분포도가 비슷하고 데이터가 많으나 SQL에서 컬럼의 조건이 많이 들어오는 경우 유용
  * ![리스트 파티셔닝](https://user-images.githubusercontent.com/68210266/131307398-824fd8c6-31fb-460a-833a-d5b31fdc9f95.PNG)

* 컴포지트 파티셔닝(Composite Partitioning)
  * 범위분할에 이후 해시 함수를 적용하여 재분할 하는 파티셔닝 기법
  * 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분산할 수 있다.
  * ![컴포지트 파티셔닝](https://user-images.githubusercontent.com/68210266/131307833-b9ce3037-9c4f-42f6-b8e9-6b99d866e493.PNG)

