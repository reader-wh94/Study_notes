## 합병 정렬(Merge Sort)

----

### 합병 정렬

* 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트를 얻는다.
* 분할 정복(divide and conquer) 기법에 바탕을 두고 있는 정렬이다.
* 즉 하나의 리스트를 2개의 작은 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결한다. 분리된 문제가 해결되지 않는다면 분할 정복 문제를 반복하여 적용한다. (순환 호출)
* 합병 정렬 단계
  1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
  2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 기법을 적용한다.
  3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 통합한다.

<br>

### 합병 정렬의 과정

![병합 정렬](https://user-images.githubusercontent.com/68210266/138544156-e12b7221-c06d-428d-9a01-97c934d9179d.PNG)

* 8 리스트를 4/4 > 2/2/2/2 >1/1/1/1/1/1/1/1 로 Divide 한다.

* 1/1 을 Conquer하고 Combine을 하여 {27}, {10}을 {10, 27}로, {12},{20}을 {20,21}로 만든다.

* 2/2 를 위와 같은 방법으로 {10, 27}, {20,21}을 {10,12,20,27}로 만든다.

* 마지막 4/4를 처음과 같은 8 리스트로 정렬, 결합하여 만든다.

  <br>

### 실제 리스트를 합하는 과정

![합병 정렬 과정](https://user-images.githubusercontent.com/68210266/138544434-09dd20f9-1b33-4ccd-bff1-fd404ab309b5.PNG)

* 2개의 리스트의 요소들을 처음부터 하나씩 비교하여 두개의 리스트 요소 중에서 더 작은 요소를 새로운 리스트로 옮긴다.
* 두 개의 리스트 중 하나가 끝날 때 까지 이 과정을 되풀이한다.
* 만약 둘 중에서 하나의 리스트가 먼저 끝나게 되면 나머지 리스트의 요소들을 전부 새로운 리스트로 복사한다.

<br>

### 합병 알고리즘 특징

* 합병 정렬은 순환 호출 구조로 되어있어서 순환 호출의 깊이는 k=log2 * n 이다.
  * 레코드의 개수 n이 2의 거듭 제곱이라고 가정하고 n = 2^3인 경우 부분 배열의 크기가 2^3 -> 2^2 -> 2^1 -> 2^0순으로 줄어든다.
  * 따라서 일반적으로 n=2^k라고 하면 부분 배열의 크기는 2^k -> 2^k-2 -> ... 2^0이 되어 순환 호출의 깊이가 k가 될 것이다.
* 하나의 합병 단계에서는 최대 n번의 비교 연산이 필요하다. 이러한 합병 단계가 k=log2 * n 번 만큼 있으므로 총 비교 연산은 최대 n * log2 * n 번 필요하다.
* 이동 연산의 경우 총 부분 배열에 들어 있는 요소의 개수가 n인 경우, 레코드의 이동이 2n번 발생하므로 하나의 합병 단계에서 2n개가 필요하다. 따라서 log2n개의 합병 단계가 필요하므로 총 2n * log2n개의 이동 연산이 필요하다.
* 즉 합병 정렬은 비교 연산과 이동 연산의 경우 O(nlog2n)의 복잡도를 가진다.

<br>

### 코드

```c++
#include <iostream>

using namespace std;
int a[10] = { 27,10,12,20,25,13,15,22};

void m_sort(int list[], int l, int m, int r) {
	int i, j, k;
	i = l;
	j = m + 1;
	k = l;
	int temp[11];

	while (i <= m && j <= r) {
		if (list[i] <= list[j])
			temp[k++] = list[i++];
		else
			temp[k++] = list[j++];
	}

	if (i > m) {
		for (int x = j; x <= r; x++)
			temp[k++] = list[x];
	} else {
		for (int x = i; x <= m; x++)
			temp[k++] = list[x];
	}

	for (int x = l; x <= r; x++)
		list[x] = temp[x];
}

void merge(int list[], int l, int r) {
	int mid;
	if (l < r) {
		mid = (l + r) / 2;
		merge(list, l, mid);
		merge(list, mid + 1, r);
		m_sort(list, l, mid, r);
	}
}
int main() {
	merge(a,0,9);
	for (int i = 0; i < 10; i++) {
		cout << a[i] << " ";
	}
	return 0;
}
```

<br>

### 시간 복잡도

최악, 평균, 최선의 경우가 모두 O(nlog2n)이다.

![시간 복잡도](https://user-images.githubusercontent.com/68210266/138546341-18b51c16-8587-403e-9717-707d27108e6d.PNG)



[코드 참고](https://hsho.tistory.com/27)